# Effective C++概览


"Effective C++" 是由 Scott Meyers 编写的一本关于 C++ 编程的书籍，它提供了一系列有关 C++ 编程的最佳实践和经验。以下是 "Effective C++" 中一些重要的经验总结：

### 1. **理解 C++ 的模型**

- C++ 是一门多范式编程语言，支持面向对象、泛型、过程式等多种编程风格。
- C++ 程序的执行模型是由构造函数和析构函数决定的。

### 2. **尽量使用 `const`、`enum` 和 `inline`**

- 使用 `const` 来确保数据不被修改，并增加编译器检测错误的机会。
- 使用 `enum` 替代 `#define`，避免宏带来的潜在问题。
- 使用 `inline` 声明函数，减少函数调用的开销。

### 3. **使用对象时遵循 RAII 原则**

- 资源获取即初始化 (Resource Acquisition Is Initialization, RAII) 是一种 C++ 中的编程习惯，可以确保在对象构造时资源被正确地分配，而在对象析构时资源被正确地释放。
- 使用智能指针、RAII 对象等机制来管理资源。

### 4. **善用函数对象和 `bind`**

- 函数对象（Functor）是可以像函数一样被调用的对象。
- `std::bind` 是 C++11 中的一个功能强大的工具，用于绑定函数和参数。

### 5. **避免 `#define` 预处理器**

- 尽量使用 `const`、`enum`、`inline` 等 C++ 特性替代 `#define`，以减少宏带来的潜在问题。

### 6. **尽量少用指针和 `new/delete`**

- 尽量使用引用而非指针，使用智能指针管理动态内存。
- 避免显式地使用 `new` 和 `delete`，而是使用智能指针、容器等 C++ 抽象。

### 7. **使用智能指针管理动态内存**

- 使用 `std::unique_ptr` 或 `std::shared_ptr` 等智能指针，可以避免手动管理动态内存带来的问题。

### 8. **理解对象复制行为**

- 默认的复制构造函数和赋值操作符可能并不总是符合预期，需要根据实际情况进行自定义实现或禁用。

### 9. **注意函数重载**

- 当使用函数重载时，需要注意隐式类型转换可能导致的二义性问题。
- 避免返回指针和引用时的二义性，尽量返回对象。

### 10. **了解异常处理机制**

- 异常处理是一种应对错误和异常情况的机制，但需要谨慎使用。
- 避免在析构函数中抛出异常，防止异常泄漏。

### 11. **关注效率**

- 了解程序的瓶颈，优化关键性能部分。
- 使用 `const` 成员函数，避免不必要的复制，尽量使用传值语义。

### 12. **了解 C++ 的编译模型**

- 了解 C++ 的编译过程，对于模板的编译机制、链接过程等有清晰的认识。

这些总结只是 "Effective C++" 中的一部分经验，书籍中还包含更多详细的内容和案例。这些经验旨在提高 C++ 程序员的编码水平，使其能够更加充分地利用 C++ 提供的强大功能。